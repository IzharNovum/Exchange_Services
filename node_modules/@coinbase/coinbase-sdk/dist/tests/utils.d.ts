/// <reference types="jest" />
import { AxiosInstance } from "axios";
import { Configuration, Wallet as WalletModel, Balance as BalanceModel, AddressBalanceList, Address as AddressModel, Transfer as TransferModel, StakingOperation as StakingOperationModel, PayloadSignature as PayloadSignatureModel, PayloadSignatureList, ContractInvocation as ContractInvocationModel, SmartContract as SmartContractModel, ValidatorList, Validator, StakingOperationStatusEnum, ValidatorStatus } from "../client";
import { HDKey } from "@scure/bip32";
export declare const mockFn: (...args: any[]) => any;
export declare const mockReturnValue: (data: any) => jest.Mock<any, any, any>;
export declare const mockReturnRejectedValue: (data: any) => jest.Mock<any, any, any>;
export declare const getAddressFromHDKey: (hdKey: HDKey) => string;
export declare const mockListAddress: (seed: string, count?: number) => {
    address_id: string;
    network_id: "base-sepolia";
    public_key: string;
    wallet_id: `${string}-${string}-${string}-${string}-${string}`;
}[];
export declare const walletId: `${string}-${string}-${string}-${string}-${string}`;
export declare const transferId: `${string}-${string}-${string}-${string}-${string}`;
export declare const amount = "0";
export declare const generateWalletFromSeed: (seed: string, count?: number) => Record<string, string>;
export declare const generateRandomHash: (length?: number) => string;
export declare const newAddressModel: (walletId: string, address_id?: string, network_id?: string, index?: number) => AddressModel;
export declare const VALID_ADDRESS_MODEL: AddressModel;
export declare const VALID_WALLET_MODEL: WalletModel;
export declare const VALID_TRANSFER_MODEL: TransferModel;
export declare const VALID_TRANSFER_SPONSORED_SEND_MODEL: TransferModel;
export declare const VALID_STAKING_OPERATION_MODEL: StakingOperationModel;
export declare const VALID_PAYLOAD_SIGNATURE_MODEL: PayloadSignatureModel;
export declare const VALID_SIGNED_PAYLOAD_SIGNATURE_MODEL: PayloadSignatureModel;
export declare const VALID_PAYLOAD_SIGNATURE_LIST: PayloadSignatureList;
export declare const MINT_NFT_ABI: {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
}[];
export declare const MINT_NFT_ARGS: {
    recipient: string;
};
export declare const VALID_CONTRACT_INVOCATION_MODEL: ContractInvocationModel;
export declare const VALID_SIGNED_CONTRACT_INVOCATION_MODEL: ContractInvocationModel;
export declare const ERC20_NAME = "Test NFT";
export declare const ERC20_SYMBOL = "TEST";
export declare const ERC20_TOTAL_SUPPLY = 100;
export declare const VALID_SMART_CONTRACT_ERC20_MODEL: SmartContractModel;
export declare const ERC721_NAME = "Test NFT";
export declare const ERC721_SYMBOL = "TEST";
export declare const ERC721_BASE_URI = "https://example.com/metadata/";
export declare const VALID_SMART_CONTRACT_ERC721_MODEL: SmartContractModel;
export declare const ERC1155_URI = "https://example.com/{id}.json";
export declare const VALID_SMART_CONTRACT_ERC1155_MODEL: SmartContractModel;
/**
 * mockStakingOperation returns a mock StakingOperation object with the provided status.
 *
 * @param status - The status of the validator.
 *
 * @returns The mock StakingOperationModel object.
 */
export declare function mockStakingOperation(status: StakingOperationStatusEnum): StakingOperationModel;
export declare const VALID_NATIVE_ETH_UNSTAKE_OPERATION_MODEL: StakingOperationModel;
export declare const VALID_ADDRESS_BALANCE_LIST: AddressBalanceList;
/**
 * mockEthereumValidator returns a mock EthereumValidator object with the provided index and status.
 *
 * @param index - The index of the validator.
 * @param status - The status of the validator.
 * @param public_key - The public key of the validator.
 *
 * @returns The mock EthereumValidator object.
 */
export declare function mockEthereumValidator(index: string, status: ValidatorStatus, public_key: string): Validator;
export declare const VALID_ACTIVE_VALIDATOR_LIST: ValidatorList;
export declare const VALID_EXITING_VALIDATOR_LIST: ValidatorList;
export declare const VALID_BALANCE_MODEL: BalanceModel;
/**
 * getAssetMock returns a mock function that returns an AssetModel with the provided network ID and asset ID.
 *
 * @returns The mock function.
 */
export declare const getAssetMock: () => any;
/**
 * AxiosMockReturn type. Represents the Axios instance, configuration, and base path.
 */
type AxiosMockType = [AxiosInstance, Configuration, string];
/**
 * Returns an Axios instance with interceptors and configuration for testing.
 *
 * @returns The Axios instance, configuration, and base path.
 */
export declare const createAxiosMock: () => AxiosMockType;
export declare const usersApiMock: {
    getCurrentUser: jest.Mock<any, any, any>;
};
export declare const assetsApiMock: {
    getAsset: jest.Mock<any, any, any>;
};
export declare const walletsApiMock: {
    getWallet: jest.Mock<any, any, any>;
    createWallet: jest.Mock<any, any, any>;
    listWallets: jest.Mock<any, any, any>;
    listWalletBalances: jest.Mock<any, any, any>;
    getWalletBalance: jest.Mock<any, any, any>;
};
export declare const addressesApiMock: {
    requestFaucetFunds: jest.Mock<any, any, any>;
    getAddress: jest.Mock<any, any, any>;
    listAddresses: jest.Mock<any, any, any>;
    getAddressBalance: jest.Mock<any, any, any>;
    listAddressBalances: jest.Mock<any, any, any>;
    createAddress: jest.Mock<any, any, any>;
    createPayloadSignature: jest.Mock<any, any, any>;
    getPayloadSignature: jest.Mock<any, any, any>;
    listPayloadSignatures: jest.Mock<any, any, any>;
};
export declare const tradeApiMock: {
    getTrade: jest.Mock<any, any, any>;
    listTrades: jest.Mock<any, any, any>;
    createTrade: jest.Mock<any, any, any>;
    broadcastTrade: jest.Mock<any, any, any>;
};
export declare const transfersApiMock: {
    broadcastTransfer: jest.Mock<any, any, any>;
    createTransfer: jest.Mock<any, any, any>;
    getTransfer: jest.Mock<any, any, any>;
    listTransfers: jest.Mock<any, any, any>;
};
export declare const stakeApiMock: {
    buildStakingOperation: jest.Mock<any, any, any>;
    getExternalStakingOperation: jest.Mock<any, any, any>;
    getStakingContext: jest.Mock<any, any, any>;
    fetchStakingRewards: jest.Mock<any, any, any>;
    fetchHistoricalStakingBalances: jest.Mock<any, any, any>;
};
export declare const walletStakeApiMock: {
    broadcastStakingOperation: jest.Mock<any, any, any>;
    createStakingOperation: jest.Mock<any, any, any>;
    getStakingOperation: jest.Mock<any, any, any>;
};
export declare const validatorApiMock: {
    getValidator: jest.Mock<any, any, any>;
    listValidators: jest.Mock<any, any, any>;
};
export declare const externalAddressApiMock: {
    listExternalAddressBalances: jest.Mock<any, any, any>;
    getExternalAddressBalance: jest.Mock<any, any, any>;
    requestExternalFaucetFunds: jest.Mock<any, any, any>;
    listAddressTransactions: jest.Mock<any, any, any>;
};
export declare const balanceHistoryApiMock: {
    listAddressHistoricalBalance: jest.Mock<any, any, any>;
};
export declare const transactionHistoryApiMock: {
    listAddressTransactions: jest.Mock<any, any, any>;
};
export declare const serverSignersApiMock: {
    listServerSigners: jest.Mock<any, any, any>;
};
export declare const contractEventApiMock: {
    listContractEvents: jest.Mock<any, any, any>;
};
export declare const smartContractApiMock: {
    createSmartContract: jest.Mock<any, any, any>;
    deploySmartContract: jest.Mock<any, any, any>;
    getSmartContract: jest.Mock<any, any, any>;
    listSmartContracts: jest.Mock<any, any, any>;
};
export declare const contractInvocationApiMock: {
    getContractInvocation: jest.Mock<any, any, any>;
    listContractInvocations: jest.Mock<any, any, any>;
    createContractInvocation: jest.Mock<any, any, any>;
    broadcastContractInvocation: jest.Mock<any, any, any>;
};
export {};
